# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

residual <- function(X, y) {
    .Call('correlateR_residual', PACKAGE = 'correlateR', X, y)
}

#' Marginal correlation matrix
#' 
#' Various workhorse functions to compute the marginal (or unconditional) 
#' correlations (and cross-correlation) estimates efficiently. 
#' They are (almost) 
#' equivalent implementations of \code{\link[stats]{cor}} in Rcpp, 
#' RcppArmadillo, and RcppEigen.
#' 
#' @rdname corFamily
#' @aliases corFamily
#'   corRcpp xcorRcpp corArma xcorArma corEigen xcorEigen
#' @param X A numeric matrix.
#' @param Y A numeric matrix of compatible dimension with the \code{X}, i.e. 
#'   \code{nrow(X)} equals \code{nrow(Y)}.
#' @return
#'   The \code{corXX} familiy returns a numeric correlation matrix of size 
#'   \code{ncol(X)} times \code{ncol(X)}.
#'   
#'   The \code{xcorXX} family returns a numeric cross-correlation matrix 
#'   of size \code{ncol(X)} times \code{ncol(Y)}.
#' @details
#'   Functions almost like \code{\link{cor}}.
#'   For the \code{xcorXX} functions, the \code{i}'th and \code{j}'th 
#'   entry of the output matrix is the correlation between \code{X[i, ]} and 
#'   \code{X[j, ]}.
#'   Likewise, for the \code{xcorXX} functions, the \code{i}'th and
#'   \code{j}'th entry of the output is the correlation between \code{X[i, ]} 
#'   and \code{Y[j, ]}.
#' @note 
#'   NA's in \code{X} or \code{Y} will yield NA's in the correlation matrix.
#'   This also includes the diagonal unlike the behaviour of 
#'   \code{\link[stats]{cor}}.
#' @author Anders Ellern Bilgrau <abilgrau (at) math.aau.dk>
#' @export
corRcpp <- function(X) {
    .Call('correlateR_corRcpp', PACKAGE = 'correlateR', X)
}

#' @rdname corFamily
#' @export
xcorRcpp <- function(X, Y) {
    .Call('correlateR_xcorRcpp', PACKAGE = 'correlateR', X, Y)
}

#' @rdname corFamily
#' @export
corArma <- function(X) {
    .Call('correlateR_corArma', PACKAGE = 'correlateR', X)
}

#' @rdname corFamily
#' @export
xcorArma <- function(X, Y) {
    .Call('correlateR_xcorArma', PACKAGE = 'correlateR', X, Y)
}

#' @rdname corFamily
#' @export
corEigen <- function(X) {
    .Call('correlateR_corEigen', PACKAGE = 'correlateR', X)
}

#' @rdname corFamily
#' @export
xcorEigen <- function(X, Y) {
    .Call('correlateR_xcorEigen', PACKAGE = 'correlateR', X, Y)
}

#' Convert covariance matrix to correlation
#' 
#' This functions converts a covariance matrix \code{S} to a correlation matrix
#' fast and efficiently.
#' 
#' @rdname cov2cor
#' @aliases cov2cor
#' @param S A square covariance matrix.
#' @return A square correlation matrix.
#' @author Anders Ellern Bilgrau <abilgrau (at) math.aau.dk>
#' @examples
#' X <- createData(n = 11, m = 4)
#' S <- cov(X)
#' stats::cov2cor(S)
#' cov2corArma(S)
#' if (require(microbenchmark)) {
#'   microbenchmark(A = cov2corArma(S),
#'                  B = stats::cov2cor(S),
#'                  C = cov2cor(S))
#' }
#' @export
cov2corArma <- function(S) {
    .Call('correlateR_cov2corArma', PACKAGE = 'correlateR', S)
}

#' Marginal covariance matrix
#' 
#' Various workhorse functions to compute the marginal (or unconditional) 
#' covariance (and cross-covariance) estimates. The functions feature both the 
#' maximum likelihood and the biased corrected estimates. They are (almost) 
#' equivalent implementations of \code{\link{stats::cov}} in Rcpp, 
#' RcppArmadillo, and RcppEigen.
#' 
#' @rdname covFamily
#' @aliases covFamily
#'   corRcpp xcorRcpp corArma xcorArma corEigen xcorEigen
#' @param X A numeric matrix.
#' @param Y A numeric matrix of compatible dimension with the \code{X}, i.e. 
#'   \code{nrow(X)} equals \code{nrow(Y)}.
#' @param norm.type an integer of length one giving the estimator. The 
#'   default \code{0L} gives the unbised estimate while \code{1L} gives the 
#'   MLE.
#' @return
#'   The \code{corXX} familiy returns a numeric correlation matrix of size 
#'   \code{ncol(X)} times \code{ncol(X)}.
#'   
#'   The \code{xcorXX} family returns a numeric cross-covariance matrix 
#'   of size \code{ncol(X)} times \code{ncol(Y)}.
#' @details
#'   Functions almost like \code{\link{cor}}.
#'   For the \code{xcorXX} functions, the \code{i}'th and \code{j}'th 
#'   entry of the output matrix is the correlation between \code{X[i, ]} and 
#'   \code{X[j, ]}.
#'   Likewise, for the \code{xcorXX} functions, the \code{i}'th and
#'   \code{j}'th entry of the output is the correlation between \code{X[i, ]} 
#'   and \code{Y[j, ]}.
#' @note 
#'   NA's in \code{X} or \code{Y} will yield NA's in the correlation matrix.
#'   This also includes the diagonal unlike the behaviour of 
#'   \code{stats::cor(X)}.
#' @author Anders Ellern Bilgrau <abilgrau (at) math.aau.dk>
#' @export
covRcpp <- function(X, norm_type = 0L) {
    .Call('correlateR_covRcpp', PACKAGE = 'correlateR', X, norm_type)
}

#' @rdname covFamily
#' @export
xcovRcpp <- function(X, Y, norm_type = 0L) {
    .Call('correlateR_xcovRcpp', PACKAGE = 'correlateR', X, Y, norm_type)
}

#' @rdname covFamily
#' @export
covArma <- function(X, norm_type = 0L) {
    .Call('correlateR_covArma', PACKAGE = 'correlateR', X, norm_type)
}

#' @rdname covFamily
#' @export
xcovArma <- function(X, Y, norm_type = 0L) {
    .Call('correlateR_xcovArma', PACKAGE = 'correlateR', X, Y, norm_type)
}

#' @rdname covFamily
#' @export
covEigen <- function(X, norm_type = 0L) {
    .Call('correlateR_covEigen', PACKAGE = 'correlateR', X, norm_type)
}

#' @rdname covFamily
#' @export
xcovEigen <- function(X, Y, norm_type = 0L) {
    .Call('correlateR_xcovEigen', PACKAGE = 'correlateR', X, Y, norm_type)
}

pcorArma <- function(X, z) {
    .Call('correlateR_pcorArma', PACKAGE = 'correlateR', X, z)
}

pcovArma <- function(X, z) {
    .Call('correlateR_pcovArma', PACKAGE = 'correlateR', X, z)
}

pxcorArma <- function(X, Y, Z) {
    .Call('correlateR_pxcorArma', PACKAGE = 'correlateR', X, Y, Z)
}

pxcovArma <- function(X, Y, Z, norm_type = 0L) {
    .Call('correlateR_pxcovArma', PACKAGE = 'correlateR', X, Y, Z, norm_type)
}

